# -*- coding: utf-8 -*-
"""DTW in kNN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EOWPYKagBYt1Gzk5fpN6WLmcLS4kG4E_

# **Imports**
"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn import preprocessing
import numpy as np
from fastdtw import fastdtw
from scipy.spatial.distance import euclidean
from sklearn.metrics import classification_report, confusion_matrix

"""# **Dataset Generation**

"""

# First feature
weather=['Sunny','Sunny','Overcast','Rainy','Rainy','Rainy','Overcast','Sunny','Sunny',
'Rainy','Sunny','Overcast','Overcast','Rainy']

# Second Feature
temp=['Hot','Hot','Hot','Mild','Cool','Cool','Cool','Mild','Cool','Mild','Mild','Mild','Hot','Mild']

# Label or target varible
play=['No','No','Yes','Yes','Yes','No','Yes','No','Yes','Yes','Yes','Yes','Yes','No']

"""# **Preprocessing using sklearn.preprocessing**"""

#creating labelEncoder
le = preprocessing.LabelEncoder()
# Converting string labels into numbers.
weather_encoded=le.fit_transform(weather)

temp_encoded=le.fit_transform(temp)
label=le.fit_transform(play)
features=list(zip(weather_encoded,temp_encoded))

"""# **Preprocessing manually**"""

def levels2binary(input):
  
  # removing duplicates by converting to dictionary and back
  input = list(dict.fromkeys(input))
  
  i=0
  while i<len(input):
    input[i] = i
    i+=1
  return input

levels2binary(weather)

"""# **The distance function manually**"""

def _dtw_distance(self, ts_a, ts_b, d = lambda x,y: abs(x-y)):
# accepts 2D numpy arrays
# DistanceMetric default = abs(x-y)
        # cost matrix
        ts_a, ts_b = np.array(ts_a), np.array(ts_b)
        M, N = len(ts_a), len(ts_b)
        cost = float("inf") * np.ones((M, N))

        # Initialize the first row and column
        cost[0, 0] = d(ts_a[0], ts_b[0])
        for i in xrange(1, M):
            cost[i, 0] = cost[i-1, 0] + d(ts_a[i], ts_b[0])

        for j in xrange(1, N):
            cost[0, j] = cost[0, j-1] + d(ts_a[0], ts_b[j])

        # Populate rest of cost matrix within window
        for i in xrange(1, M):
            for j in xrange(max(1, i - max_warping_window),
                            min(N, i + max_warping_window)):
                choices = cost[i - 1, j - 1], cost[i, j-1], cost[i-1, j]
                cost[i, j] = min(choices) + d(ts_a[i], ts_b[j])

        # Return DTW distance given window 
        return cost[-1, -1]

def _dist_matrix(x, y): 
        else:
            x_s = np.shape(x)
            y_s = np.shape(y)
            dm = np.zeros((x_s[0], y_s[0])) 
            dm_size = x_s[0]*y_s[0]
            
            p = ProgressBar(dm_size)
        
            for i in xrange(0, x_s[0]):
                for j in xrange(0, y_s[0]):
                    dm[i, j] = self._dtw_distance(x[i, ::step],
                                                  y[j, ::step])
                    # Update progress bar
                    dm_count += 1
                    p.animate(dm_count)
        
            return dm
def predict(x):
        
        dist_matrix(x, x)

        # Identify the k nearest neighbors
        knn_idx = dm.argsort()[:, :n_neighbors]

        # Identify k nearest labels
        knn_labels = l[knn_idx]
        
        # Model Label
        mode_data = mode(knn_labels, axis=1)
        mode_label = mode_data[0]
        mode_proba = mode_data[1]/n_neighbors

        return mode_label.ravel(), mode_proba.ravel()

"""# **The distance function using fastdtw**"""

x = np.array(temp_encoded)
y = np.array(label)

distance, path = fastdtw(x, y, dist=euclidean)
print(distance)

def dtw(x, y):
  result = fastdtw(x, y, dist=euclidean)[0]
  return result

"""# **Fitting the model I guess**"""

model = KNeighborsClassifier(n_neighbors=3, metric = dtw)

# Train the model using the training sets
model.fit(temp_encoded.reshape(-1,1),label)

#Predict output
predicted= model.predict([[0]])
print(predicted)

"""# **Evaluating the model**"""

print classification_report(label, y_test[::10],
                            target_names=[l for l in labels.values()])

conf_mat = confusion_matrix(label, y_test[::10])

fig = plt.figure(figsize=(6,6))
width = np.shape(conf_mat)[1]
height = np.shape(conf_mat)[0]

res = plt.imshow(np.array(conf_mat), cmap=plt.cm.summer, interpolation='nearest')
for i, row in enumerate(conf_mat):
    for j, c in enumerate(row):
        if c>0:
            plt.text(j-.2, i+.1, c, fontsize=16)
            
cb = fig.colorbar(res)
plt.title('Confusion Matrix')
_ = plt.xticks(range(6), [l for l in labels.values()], rotation=90)
_ = plt.yticks(range(6), [l for l in labels.values()])